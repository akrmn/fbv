## Consulta Q11: Proveedor con el mínimo costo

La consulta a optimizar es la siguiente:

```sql
select
  s_acctbal,
  s_name,
  n_name,
  p_partkey,
  p_mfgr,
  s_address,
  s_phone,
  s_comment
from
  part,
  supplier,
  partsupp,
  nation,
  region
where
  p_partkey = ps_partkey
  and s_suppkey = ps_suppkey
  and p_size = $1
  and p_type like $2
  and s_nationkey = n_nationkey
  and n_regionkey = r_regionkey
  and r_name = $3
  and ps_supplycost = (
    select
      min(ps_supplycost)
    from
      partsupp,
      supplier,
      nation,
      region
    where
      p_partkey = ps_partkey
      and s_suppkey = ps_suppkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = $3
  )
order by
  s_acctbal desc,
  n_name,
  s_name,
  p_partkey;
```

Al hacer `Explain Analyze` sobre la consulta sin ningúna estructura adicional se
obtuvo el plan de ejecución mostrado en la Figura INSERTARNUMERO, con una
duración total de 1956 ms. Puede verse que el nodo más caro y lento en este
grafo fue el *Seq Scan* que se hace sobre `partsupp` como parte del *Hash Join*
con la tabla `supplier` sobre la igualdad de los atributos `ps_suppkey` y
`s_suppkey`, cuyos nombres indican que se trata de un join sobre una clave
foránea entre la entidad `partsupp` y su `supplier` correspondiente.

![Arbol de ejecucion de la consulta Q11 original](img/plan_q11original.pdf)

Cabe mencionar que antes de plantear cualquier cambio a la estructura de una
base de datos para mejorar el desempeño de una consulta, es buena idea revisar
la consulta en sí. En este caso, puede notarse que la consulta tiene una
sub-consulta correlacionada, en la cual se busca el costo mínimo para una pieza
entre todos los proveedores. Esta sub-consulta puede entonces reescribirse con
una *Common Table Expression* para evitar que se evalúe más de una vez por cada
pieza. Resulta entonces la siguiente consulta con idéntica semántica:

```sql
with minPerPart as (
  select
    min(ps_supplycost) as mpp_mincost,
    p_partkey          as mpp_partkey
  from
    part,
    partsupp,
    supplier,
    nation,
    region
  where p_partkey          = ps_partkey
    and ps_suppkey         = s_suppkey
    and s_nationkey        = n_nationkey
    and n_regionkey        = r_regionkey
    and p_size             = $1
    and reverse(p_type) like reverse($2)
    and r_name             = $3
  group by
    mpp_partkey
  order by
    mpp_partkey
)
select
  s_acctbal,
  s_name,
  n_name,
  p_partkey,
  p_mfgr,
  s_address,
  s_phone,
  s_comment
from
  part,
  supplier,
  partsupp,
  nation,
  region,
  minPerPart
where p_partkey     = ps_partkey
  and ps_suppkey    = s_suppkey
  and s_nationkey   = n_nationkey
  and p_size        = $1
  and p_type     like $2
  and r_name        = $3
  and ps_supplycost = mpp_mincost
  and p_partkey     = mpp_partkey
order by
  s_acctbal desc,
  n_name,
  s_name,
  p_partkey;
```

Luego de reescribir la consulta, agregamos un par de índices a la base de
datos. El primero lo creamos sobre la tabla `part`, en las columnas `p_size`
y el reverso de `p_type`, en ese órden. Éste índice le permite al manejador
conseguir primero las piezas de un tamaño específico, y luego las que tengan
un sufijo en particular. Como nos interesa que la comparación sea por sufijo en
lugar de por prefijo, sólo tiene sentido usar el reverso de `p_type`. Los
atributos del índice están en este órden porque invertirlos no permitiría hacer
búsquedas por igualdad en el atributo p_size, que es lo que se desea en esta
consulta.

```sql
create index if not exists idx_q11_p_size_reverse_type
  on part (p_size, reverse(p_type) text_pattern_ops);
```

El segundo índice que agregamos para esta consulta es sobre la tabla `partsupp`,
en los atributos `ps_partkey`, `ps_suppkey`, `ps_supplycost`, y permite que
dos operaciones *Join* utilicen *Index Only Scan*s en el lado interno, en
lugar de la costosa secuencia *Bitmap Index Scan - Bitmap Heap Scan* sobre una
tabla del tamaño de `partsupp`

```sql
create index if not exists idx_q11_partsupp
  on partsupp (ps_partkey, ps_suppkey, ps_supplycost);
```

Luego de la reescritura de la consulta y la creación del par de índices, el
tiempo de ejecución (con caché fría) de esta consulta baja de 1956 ms a 621 ms,
tan sólo el 32% del tiempo de la consulta original. El plan resultante es el
mostrado en la figura INSERTENUMERO.

![Arbol de ejecucion de la consulta Q11 modificada](img/plan_q11improved.pdf)
